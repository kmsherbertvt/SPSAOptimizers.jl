<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SPSAOptimizers.jl</title><meta name="title" content="Home · SPSAOptimizers.jl"/><meta property="og:title" content="Home · SPSAOptimizers.jl"/><meta property="twitter:title" content="Home · SPSAOptimizers.jl"/><meta name="description" content="Documentation for SPSAOptimizers.jl."/><meta property="og:description" content="Documentation for SPSAOptimizers.jl."/><meta property="twitter:description" content="Documentation for SPSAOptimizers.jl."/><meta property="og:url" content="https://kmsherbertvt.github.io/SPSAOptimizers.jl/"/><meta property="twitter:url" content="https://kmsherbertvt.github.io/SPSAOptimizers.jl/"/><link rel="canonical" href="https://kmsherbertvt.github.io/SPSAOptimizers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SPSAOptimizers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SPSAOptimizers"><a class="docs-heading-anchor" href="#SPSAOptimizers">SPSAOptimizers</a><a id="SPSAOptimizers-1"></a><a class="docs-heading-anchor-permalink" href="#SPSAOptimizers" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/kmsherbertvt/SPSAOptimizers.jl">SPSAOptimizers</a>.</p><ul><li><a href="#SPSAOptimizers.DictStreams"><code>SPSAOptimizers.DictStreams</code></a></li><li><a href="#SPSAOptimizers.PowerStreams"><code>SPSAOptimizers.PowerStreams</code></a></li><li><a href="#SPSAOptimizers.QiskitInterface"><code>SPSAOptimizers.QiskitInterface</code></a></li><li><a href="#SPSAOptimizers.RandomStreams"><code>SPSAOptimizers.RandomStreams</code></a></li><li><a href="#SPSAOptimizers.Serialization"><code>SPSAOptimizers.Serialization</code></a></li><li><a href="#SPSAOptimizers.ConstantStreams.ConstantSeries"><code>SPSAOptimizers.ConstantStreams.ConstantSeries</code></a></li><li><a href="#SPSAOptimizers.DictStreams.IntDictStream"><code>SPSAOptimizers.DictStreams.IntDictStream</code></a></li><li><a href="#SPSAOptimizers.FirstOrderOptimizers.FirstOrderOptimizer"><code>SPSAOptimizers.FirstOrderOptimizers.FirstOrderOptimizer</code></a></li><li><a href="#SPSAOptimizers.Hessians.HessianType"><code>SPSAOptimizers.Hessians.HessianType</code></a></li><li><a href="#SPSAOptimizers.Optimizers.OptimizerType"><code>SPSAOptimizers.Optimizers.OptimizerType</code></a></li><li><a href="#SPSAOptimizers.PowerStreams.PowerSeries"><code>SPSAOptimizers.PowerStreams.PowerSeries</code></a></li><li><a href="#SPSAOptimizers.RandomStreams.BernoulliDistribution"><code>SPSAOptimizers.RandomStreams.BernoulliDistribution</code></a></li><li><a href="#SPSAOptimizers.SPSA1s.SPSA1"><code>SPSAOptimizers.SPSA1s.SPSA1</code></a></li><li><a href="#SPSAOptimizers.SPSA2s.SPSA2"><code>SPSAOptimizers.SPSA2s.SPSA2</code></a></li><li><a href="#SPSAOptimizers.SecondOrderOptimizers.SecondOrderOptimizer"><code>SPSAOptimizers.SecondOrderOptimizers.SecondOrderOptimizer</code></a></li><li><a href="#SPSAOptimizers.Streams.StreamType"><code>SPSAOptimizers.Streams.StreamType</code></a></li><li><a href="#SPSAOptimizers.TrajectoryHessians.TrajectoryHessian"><code>SPSAOptimizers.TrajectoryHessians.TrajectoryHessian</code></a></li><li><a href="#SPSAOptimizers.Hessians.regularized"><code>SPSAOptimizers.Hessians.regularized</code></a></li><li><a href="#SPSAOptimizers.Hessians.update!"><code>SPSAOptimizers.Hessians.update!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.Record"><code>SPSAOptimizers.Optimizers.Record</code></a></li><li><a href="#SPSAOptimizers.Optimizers.Trace-Tuple{}"><code>SPSAOptimizers.Optimizers.Trace</code></a></li><li><a href="#SPSAOptimizers.Optimizers.averagerecords!-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.averagerecords!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.copyrecord!-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.copyrecord!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.iterate!"><code>SPSAOptimizers.Optimizers.iterate!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.optimize!"><code>SPSAOptimizers.Optimizers.optimize!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.trace!-Tuple{Any, Any, Vararg{Any}}"><code>SPSAOptimizers.Optimizers.trace!</code></a></li><li><a href="#SPSAOptimizers.Optimizers.trajectory-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.trajectory</code></a></li><li><a href="#SPSAOptimizers.QiskitInterface.SPSA-Tuple{Int64}"><code>SPSAOptimizers.QiskitInterface.SPSA</code></a></li><li><a href="#SPSAOptimizers.QiskitInterface.minimize-Tuple{Any, Any, Any}"><code>SPSAOptimizers.QiskitInterface.minimize</code></a></li><li><a href="#SPSAOptimizers.RandomStreams.sample-Tuple{SPSAOptimizers.RandomStreams.BernoulliDistribution, Any}"><code>SPSAOptimizers.RandomStreams.sample</code></a></li><li><a href="#SPSAOptimizers.Serialization.__data__"><code>SPSAOptimizers.Serialization.__data__</code></a></li><li><a href="#SPSAOptimizers.Serialization.deserialize-Tuple{Any}"><code>SPSAOptimizers.Serialization.deserialize</code></a></li><li><a href="#SPSAOptimizers.Serialization.init"><code>SPSAOptimizers.Serialization.init</code></a></li><li><a href="#SPSAOptimizers.Serialization.load!"><code>SPSAOptimizers.Serialization.load!</code></a></li><li><a href="#SPSAOptimizers.Serialization.reset!"><code>SPSAOptimizers.Serialization.reset!</code></a></li><li><a href="#SPSAOptimizers.Serialization.serialize-Tuple{Any}"><code>SPSAOptimizers.Serialization.serialize</code></a></li><li><a href="#SPSAOptimizers.Streams.next!-Tuple{SPSAOptimizers.ConstantStreams.ConstantSeries}"><code>SPSAOptimizers.Streams.next!</code></a></li><li><a href="#SPSAOptimizers.Streams.next!"><code>SPSAOptimizers.Streams.next!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization" href="#SPSAOptimizers.Serialization"><code>SPSAOptimizers.Serialization</code></a> — <span class="docstring-category">Module</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.__data__" href="#SPSAOptimizers.Serialization.__data__"><code>SPSAOptimizers.Serialization.__data__</code></a> — <span class="docstring-category">Function</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.deserialize-Tuple{Any}" href="#SPSAOptimizers.Serialization.deserialize-Tuple{Any}"><code>SPSAOptimizers.Serialization.deserialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deserialize(json)</code></pre><p>Convert a JSON-serializable NamedTuple into an object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.init" href="#SPSAOptimizers.Serialization.init"><code>SPSAOptimizers.Serialization.init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init(::Type{&lt;:Serializable}, data)</code></pre><p>Ignore mutable attributes in data; just set state-independent values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.load!" href="#SPSAOptimizers.Serialization.load!"><code>SPSAOptimizers.Serialization.load!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load!(::Serializable, data)</code></pre><p>Ignore immutable attributes in data; just change state-dependent values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.reset!" href="#SPSAOptimizers.Serialization.reset!"><code>SPSAOptimizers.Serialization.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset!(::Serializable)</code></pre><p>Restore mutable attributes to their initial values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Serialization.serialize-Tuple{Any}" href="#SPSAOptimizers.Serialization.serialize-Tuple{Any}"><code>SPSAOptimizers.Serialization.serialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">serialize(object)</code></pre><p>Convert an object into a JSON-serializable NamedTuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/serialization.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Streams.StreamType" href="#SPSAOptimizers.Streams.StreamType"><code>SPSAOptimizers.Streams.StreamType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StreamType{T}</code></pre><p>Concrete StreamTypes should implement the interface for serialization     (<strong>data</strong>, init, load!, reset!, along with calling <code>register</code>)     in addition to the <code>next!</code> function, which returns an object of type T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Streams.next!" href="#SPSAOptimizers.Streams.next!"><code>SPSAOptimizers.Streams.next!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next!(stream::StreamType{T})</code></pre><p>Returns the next element of type T from the given stream object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.PowerStreams" href="#SPSAOptimizers.PowerStreams"><code>SPSAOptimizers.PowerStreams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Guidelines for selecting gain sequences:</p><p>Let η[k] = η0 / (A + k + 1)^α     h[k] = h0 / (k + 1)^γ</p><ul><li><p>Asymptotically optimal: α=1, γ=1/6</p></li><li><p>Lowest allowable for theoretical convergence: α=0.602, γ=0.101</p></li><li><p>Empirically, the smaller the better, but maybe for large problems one should transition to the larger.</p></li><li><p>Set h0 to the standard deviation of the noise in f.</p></li><li><p>Set A to 10% of the maximum number of iterations.</p></li><li><p>Set a0 such that a[0] * |g(x0)| gives a desirable &quot;change in magnitude&quot; of x.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/seriesstreams.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.PowerStreams.PowerSeries" href="#SPSAOptimizers.PowerStreams.PowerSeries"><code>SPSAOptimizers.PowerStreams.PowerSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerSeries(a0, γ, A)</code></pre><p>Yield from the sequence <span>$a[k] = a_0 / (A + k + 1)^γ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/seriesstreams.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.ConstantStreams.ConstantSeries" href="#SPSAOptimizers.ConstantStreams.ConstantSeries"><code>SPSAOptimizers.ConstantStreams.ConstantSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantSeries(C)</code></pre><p>Yield the number C, every time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/seriesstreams.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Streams.next!-Tuple{SPSAOptimizers.ConstantStreams.ConstantSeries}" href="#SPSAOptimizers.Streams.next!-Tuple{SPSAOptimizers.ConstantStreams.ConstantSeries}"><code>SPSAOptimizers.Streams.next!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/seriesstreams.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.RandomStreams" href="#SPSAOptimizers.RandomStreams"><code>SPSAOptimizers.RandomStreams</code></a> — <span class="docstring-category">Module</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/randomstreams.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.RandomStreams.BernoulliDistribution" href="#SPSAOptimizers.RandomStreams.BernoulliDistribution"><code>SPSAOptimizers.RandomStreams.BernoulliDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BernoulliDistribution(L, k, p, seed)</code></pre><p>A Bernoulli distribution yielding a vector of +/-1.</p><p><strong>Parameters</strong></p><ul><li>L::Int, the length of the vector to generate</li><li>k::Int=L, the number of elements in the vector to randomize   If an element isn&#39;t randomized, it is set to 0.   Which elements to randomize are...selected randomly. :)</li><li>p::Int=1.0, the probability of randomizing any given element in the vector</li></ul><p>NOTE: k and p are different and mutually exclusive ways     to let 0&#39;s sneak into the Bernoulli distribution. The defaults are just &quot;no 0&#39;s allowed&quot;,         i.e. an actual Bernoulli distribution.</p><ul><li>seed::Int, the random seed defining the pseudorandom stream</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/randomstreams.jl#L12-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.RandomStreams.sample-Tuple{SPSAOptimizers.RandomStreams.BernoulliDistribution, Any}" href="#SPSAOptimizers.RandomStreams.sample-Tuple{SPSAOptimizers.RandomStreams.BernoulliDistribution, Any}"><code>SPSAOptimizers.RandomStreams.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><p>NOTE: r=1.0 is defined to give 0, irrespective of X.p</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/randomstreams.jl#L80-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.DictStreams" href="#SPSAOptimizers.DictStreams"><code>SPSAOptimizers.DictStreams</code></a> — <span class="docstring-category">Module</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/dictstreams.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.DictStreams.IntDictStream" href="#SPSAOptimizers.DictStreams.IntDictStream"><code>SPSAOptimizers.DictStreams.IntDictStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntDictStream(dict, default)</code></pre><p>A customized stream specifying the output for any given specific iteration in <code>dict</code>,     or otherwise a fixed constant <code>default</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/streams/dictstreams.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Hessians.HessianType" href="#SPSAOptimizers.Hessians.HessianType"><code>SPSAOptimizers.Hessians.HessianType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An internal representation of a &quot;tracked&quot; Hessian,     e.g. the average of Hessians measured at each iteration in the trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/hessians.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Hessians.regularized" href="#SPSAOptimizers.Hessians.regularized"><code>SPSAOptimizers.Hessians.regularized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regularized(H::HessianType{F})</code></pre><p>A bit of post-processing to construct a positive semi-definite version of <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/hessians.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Hessians.update!" href="#SPSAOptimizers.Hessians.update!"><code>SPSAOptimizers.Hessians.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update!(H::HessianType{F}, Hm::AbstractMatrix{F})</code></pre><p>Update the &quot;tracked&quot; Hessian <code>H</code> with the &quot;measured&quot; Hessian <code>Hm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/hessians.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.TrajectoryHessians.TrajectoryHessian" href="#SPSAOptimizers.TrajectoryHessians.TrajectoryHessian"><code>SPSAOptimizers.TrajectoryHessians.TrajectoryHessian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrajectoryHessian(bias, H, k)</code></pre><p>Hessian is average of Hessians from each iteration in trajectory.</p><p><strong>Parameters</strong></p><ul><li><p>bias::Float - the regularization bias,   i.e. the iotum of an identity matrix to add   when computing a positive semi-definite version of this matrix</p></li><li><p>H::Matrix{Float} - the average Hessian over all <code>k</code> iterations</p></li><li><p>k::Ref{Int} - the number of iterations over which <code>H</code> is averaged</p><p>TrajectoryHessian(L; bias)</p></li></ul><p>Convenience constructor which initializes <code>H</code> to an LxL matrix,     and <code>k</code> to 0. The <code>bias</code> defaults to 0.01 but can be overridden.</p><p>Note that we initialize <code>H</code> to identity, but this does not matter because,     with k=0, it will be weighted by 0 in the first update!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/hessians.jl#L33-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.OptimizerType" href="#SPSAOptimizers.Optimizers.OptimizerType"><code>SPSAOptimizers.Optimizers.OptimizerType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Used for dispatch to different optimization algorithms.</p><p>Algorithms are organized by first-order, second-order, and so on. (Well, just those two for now,     but I feel like there could be a &quot;quasi-second order&quot; someday.)</p><p>Constructors are documented with concrete types (e.g. <code>SPSA1</code>),     but details on optimization options,     record schematics, and <code>iterate!</code> keyword arguments     are found in the intermediate order types, e.g. <code>FirstOrderOptimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.Record" href="#SPSAOptimizers.Optimizers.Record"><code>SPSAOptimizers.Optimizers.Record</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Record(optimizer, L)</code></pre><p>Initialize a mutable object giving the status of an <code>L</code>-dimensional optimization.</p><p>The object is a <code>NamedTuple</code> of vectors and references,     whose precise schema depends on the type of <code>optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L94-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.Trace-Tuple{}" href="#SPSAOptimizers.Optimizers.Trace-Tuple{}"><code>SPSAOptimizers.Optimizers.Trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Trace()</code></pre><p>Initialize a vector of Records, giving a trace of an optimization.</p><p>Simply allows for the more intuitive trace initialization, <code>Trace()</code>. Asking people to type <code>NamedTuple[]</code> just sounds so...pretentious.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.averagerecords!-Tuple{Any, Any}" href="#SPSAOptimizers.Optimizers.averagerecords!-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.averagerecords!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">averagerecords!(archive, records)</code></pre><p>Like <code>copyrecord!</code>, but stores an average of many records in <code>archive</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.copyrecord!-Tuple{Any, Any}" href="#SPSAOptimizers.Optimizers.copyrecord!-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.copyrecord!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyrecord!(archive, record)</code></pre><p>Copy all values from the <code>record</code> Record to the <code>archive</code> Record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.iterate!" href="#SPSAOptimizers.Optimizers.iterate!"><code>SPSAOptimizers.Optimizers.iterate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate!(optimizer, fn, x; kwargs...)</code></pre><p>Advance by one step in an optimization routine, updating <code>x</code> in place.</p><p>In addition to updating <code>x</code>, this will update the state of <code>optimizer</code>.</p><p><strong>Parameters</strong></p><ul><li>optimizer::OptimizerType{F} - defines the optimization algorithm</li><li>fn - the loss-function, such that fn(x) returns a number of type F</li><li>x::AbstractVector{F} - the best guess so far</li></ul><p>Keyword arguments depend on the type of <code>optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.optimize!" href="#SPSAOptimizers.Optimizers.optimize!"><code>SPSAOptimizers.Optimizers.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize!(optimizer, fn, x0; kwargs...)</code></pre><p>Run an optimization routine to convergence, updating <code>x</code> in place.</p><p>In addition to updating <code>x</code>, this will update the state of <code>optimizer</code>.</p><p><strong>Parameters</strong></p><ul><li>optimizer::OptimizerType{F} - defines the optimization algorithm</li><li>fn - the loss-function, such that fn(x) returns a number of type F</li><li>x::AbstractVector{F} - the best guess so far</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p>maxiter::Int - the max number of iterations to attempt, successful or not</p></li><li><p>callback - function called at each iteration, successful or not:</p><p>callback(optimizer, iterate)</p><p>where <code>iterate</code> is a record of the proposed step. The callback is called immediately prior   to deciding whether to accept or reject the step,   and the step is always rejected if the callback returns true.</p></li><li><p>record, average_last, trace, tracefields - see Output section below</p></li></ul><p>Additional keyword arguments may be available     depending on the type of <code>optimizer</code>.</p><p><strong>Output</strong></p><p>A <code>record</code> (a <code>NamedTuple</code> with schema specified by the <code>optimizer</code>)     is returned at the end. If you provide an integer to <code>average_last</code>,     that record is an average of the last so many (successful) iterations.</p><p>If you provide an object to the <code>record</code> keyword argument,     that object will be the one used for the final return output. More importantly, this same object is used to keep track of the     last successful iteration,     so it will have meaningful data if something (e.g. keyboard interrupt)     disrupts the algorithm. Note however that if terminated prematurely,     <code>record</code> will only represent the last successful iteration,     rather than an average, even if <code>average_last</code> is provided.</p><p>You can also provide a <code>trace</code>,     which is a list of records of every single step. Provide a collection of field names (as symbols) to specify which fields     should be saved in the trace. The default is the collection of all scalar attributes. Set it to an empty collection to trace every possible attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L36-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.trace!-Tuple{Any, Any, Vararg{Any}}" href="#SPSAOptimizers.Optimizers.trace!-Tuple{Any, Any, Vararg{Any}}"><code>SPSAOptimizers.Optimizers.trace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trace!(trace, record, fields...)</code></pre><p>Copies a record and adds the copy to the trace.</p><p>Optionally, list specific fields - all others will be omitted from the copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.Optimizers.trajectory-Tuple{Any, Any}" href="#SPSAOptimizers.Optimizers.trajectory-Tuple{Any, Any}"><code>SPSAOptimizers.Optimizers.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trajectory(trace, field)</code></pre><p>Extract the values of a particular field from each record in a trace,     and return as a vector (if <code>field</code> names a reference)     or a matrix, where each column is the vector stored in one record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.FirstOrderOptimizers.FirstOrderOptimizer" href="#SPSAOptimizers.FirstOrderOptimizers.FirstOrderOptimizer"><code>SPSAOptimizers.FirstOrderOptimizers.FirstOrderOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FirstOrderOptimizer{F}</code></pre><p>Super-type for first-order optimizers. (I&#39;m pretty sure there&#39;s just the one, <code>SPSA1</code>.) Constructors are documented with the concrete type(s?),     but find details on optimization options,     record schematics, and <code>iterate!</code> keyword arguments here:</p><p><strong><code>Record</code> Schematic</strong></p><pre><code class="nohighlight hljs">Record(::FirstOrderOptimizer{F}, L::Int)</code></pre><p>Constructs a <code>NamedTuple</code> with fields</p><ul><li>x::Vector{F} of length L, the current parameters</li><li>f::Ref{F}, the current function value</li><li>g::Vector{F} of length L, the current gradient estimate</li><li>p::Vector{F} of length L, the current parameter step (based on gradient)</li><li>xp::Vector{F} of length L, the proposed parameters for the next iteration</li><li>fp::Ref{F}, the function value at the next iteration</li><li>nfev::Ref{Int}, the number of function evaluations to date</li><li>time::Ref{F}, the algorithm time to date</li><li>bytes::Ref{F}, the memory consumption to date</li></ul><p><strong>Additional <code>optimize!</code> Keyword Arguments</strong></p><ul><li><p>trust::F=Inf, the maximum allowable norm of <code>p</code></p><p>If <code>p</code> has a larger norm, it gets clipped to <code>trust</code>.</p></li><li><p>tolerance::F=Inf, the amount by which <code>fp</code> may exceed <code>f</code> without rejecting the step</p></li></ul><p><strong><code>iterate!</code> Interface</strong></p><pre><code class="nohighlight hljs">iterate!(
    optimizer, fn, x;
    # EXTRA OPTIONS
    trust,
    # TRACEABLES
    f, g, p, xp, nfev,
    # WORK ARRAYS
    __xe
)</code></pre><ul><li>optimizer, fn, x: the mandatory positional arguments, see <code>iterate!</code></li><li>trust: see above</li><li>f, g, p, xp, nfev: when provided, stores meaningful outputs   (when called through <code>optimize!</code>,       these are provided from the <code>record</code> of the last successful iteration).</li><li>__xe: a work variable matching the dimensions of x,   used to store the stochastically perturbed parameters for finite difference</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers/firstorder.jl#L4-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.SPSA1s.SPSA1" href="#SPSAOptimizers.SPSA1s.SPSA1"><code>SPSAOptimizers.SPSA1s.SPSA1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SPSA1{P}(η, h, e, n)</code></pre><p>The first-order SPSA optimizer.</p><p><strong>Type Parameters</strong></p><ul><li>P::Int, the order of finite difference, typically 2</li></ul><p><strong>Parameters</strong></p><ul><li>η - the float stream for step-length at each iteration</li><li>h - the float stream for finite-difference perturbation at each iteration</li><li>e - the vector stream for each finite difference perturbation direction   This also determines the dimensions in the parameter vector.</li><li>n - the int stream for number of times to sample the gradient at each iteration</li></ul><pre><code class="nohighlight hljs">SPSA1(L; P, η, h, e, n)</code></pre><p>With this constructor, you need only provide the number of dimensions <code>L</code>,     and all the above parameters will be filled in by sensible defaults     (but you can override any of them with the kwarg).</p><p>Additionally, you may use the <code>η</code> and <code>h</code> kwargs to specify tuples     defining a power series.</p><p><strong>Defaults</strong></p><ul><li>P: 2, of course - central finite difference</li><li>η: a power series with a0 = 0.2, alpha=0.602, and A = 0</li><li>h: a power series with c0 = 0.2 and gamma=0.101</li><li>e: a fair coin-toss between +/-1 for each dimension</li><li>n: one sample for every iteration</li></ul><p><strong>Tuple Interface</strong></p><p>If you don&#39;t feel like manually constructing the PowerStream object,     you can just pass a tuple directly here.</p><ul><li>η: <code>(a0, alpha, A)</code> all floats (even though A is semantically an integer)</li><li>h: <code>(c0, gamma)</code> all floats (note A is always 0 for the h stream)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers/firstorder.jl#L198-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.SecondOrderOptimizers.SecondOrderOptimizer" href="#SPSAOptimizers.SecondOrderOptimizers.SecondOrderOptimizer"><code>SPSAOptimizers.SecondOrderOptimizers.SecondOrderOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SecondOrderOptimizer{F}</code></pre><p>Super-type for first-order optimizers. (Just <code>SPSA2</code> for now but I have visions of how to enhance.     They probably aren&#39;t worth the effort, though.) Constructors are documented with the concrete type(s?),     but find details on optimization options,     record schematics, and <code>iterate!</code> keyword arguments here:</p><p><strong><code>Record</code> Schematic</strong></p><pre><code class="nohighlight hljs">Record(::FirstOrderOptimizer{F}, L::Int)</code></pre><p>Constructs a <code>NamedTuple</code> with fields</p><ul><li>x::Vector{F} of length L, the current parameters</li><li>f::Ref{F}, the current function value</li><li>g::Vector{F} of length L, the current gradient estimate</li><li>H::Matrix{F} of size(L,L), the current Hessian estimate</li><li>p::Vector{F} of length L, the current parameter step (based on gradient)</li><li>xp::Vector{F} of length L, the proposed parameters for the next iteration</li><li>fp::Ref{F}, the function value at the next iteration</li><li>nfev::Ref{Int}, the number of function evaluations to date</li><li>time::Ref{F}, the algorithm time to date</li><li>bytes::Ref{F}, the memory consumption to date</li></ul><p><strong>Additional <code>optimize!</code> Keyword Arguments</strong></p><ul><li><p>trust::F=Inf, the maximum allowable norm of <code>p</code></p><p>If <code>p</code> has a larger norm, it gets clipped to <code>trust</code>.</p></li><li><p>tolerance::F=Inf, the amount by which <code>fp</code> may exceed <code>f</code> without rejecting the step</p></li><li><p>warmup::Int=0, after how many iterations to begin refining the step with the Hessian   (rather than just using gradient directly)</p></li><li><p>solver, a function with header <code>solver(H, g)</code>   returning the &quot;preconditioned&quot; <span>$H^{-1} g$</span></p></li></ul><p><strong><code>iterate!</code> Interface</strong></p><pre><code class="nohighlight hljs">iterate!(
    optimizer, fn, x;
    # EXTRA OPTIONS
    trust, precondition, solver,
    # TRACEABLES
    f, g, H, p, xp, nfev,
    # WORK ARRAYS
    __xe,
    __e1,
)</code></pre><ul><li>optimizer, fn, x: the mandatory positional arguments, see <code>iterate!</code></li><li>trust, solver: see above</li><li>precondition: whether or not to use the Hessian in this iteration</li><li>f, g, H, p, xp, nfev: when provided, stores meaningful outputs   (when called through <code>optimize!</code>,       these are provided from the <code>record</code> of the last successful iteration).</li><li>__xe: a work variable matching the dimensions of x,   Used to store the stochastically perturbed parameters for finite difference</li><li>__e1: a work variable matching the dimensions of x   Used to store one of the two perturbation vectors       needed for second order finite difference.   Note that the other one is stored within the stream object,       which is why this isn&#39;t needed at all in first-order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers/secondorder.jl#L4-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.SPSA2s.SPSA2" href="#SPSAOptimizers.SPSA2s.SPSA2"><code>SPSAOptimizers.SPSA2s.SPSA2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SPSA2(H, η, h, e, n)</code></pre><p>The second-order SPSA optimizer.</p><p><strong>Parameters</strong></p><ul><li>H - the Hessian object, updated at each iteration</li><li>η - the float stream for step-length at each iteration</li><li>h - the float stream for finite-difference perturbation at each iteration</li><li>e - the vector stream for each finite difference perturbation direction   This also determines the dimensions in the parameter vector.</li><li>n - the int stream for number of times to sample the gradient at each iteration</li></ul><pre><code class="nohighlight hljs">SPSA2(L; H, η, h, e, n)</code></pre><p>With this constructor, you need only provide the number of dimensions <code>L</code>,     and all the above parameters will be filled in by sensible defaults     (but you can override any of them with the kwarg).</p><p>Additionally, you may use the <code>η</code> and <code>h</code> kwargs to specify tuples     defining a power series.</p><p><strong>Defaults</strong></p><ul><li>H: a fresh LxL <code>TrajectoryHessian</code> with regularization bias 0.01</li><li>η: a power series with a0 = 0.2, alpha=0.602, and A = 0</li><li>h: a power series with c0 = 0.2 and gamma=0.101</li><li>e: a fair coin-toss between +/-1 for each dimension</li><li>n: one sample for every iteration</li></ul><p><strong>Tuple Interface</strong></p><p>If you don&#39;t feel like manually constructing the PowerStream object,     you can just pass a tuple directly here.</p><ul><li>η: <code>(a0, alpha, A)</code> all floats (even though A is semantically an integer)</li><li>h: <code>(c0, gamma)</code> all floats (note A is always 0 for the h stream)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/optimizers/secondorder.jl#L223-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.QiskitInterface" href="#SPSAOptimizers.QiskitInterface"><code>SPSAOptimizers.QiskitInterface</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Using qiskit, one might do:</p><pre><code class="nohighlight hljs">```

import qiskit_algorithms
import qiskit_algorithms.optimizers as qopt

qiskit_algorithms.utils.algorithm_globals.random_seed = seed

get_eta = lambda: qopt.spsa.powerseries(eta=a0, power=alpha, offset=A)
get_eps = lambda: qopt.spsa.powerseries(eta=c0, power=gamma)

spsa = qopt.SPSA(
    learning_rate = get_eta,
    perturbation = get_eps,
    **kwargs
)

result = spsa.minimize(fn, x0)

```</code></pre><p>With this module, one could do this:</p><pre><code class="nohighlight hljs">```
import SPSAOptimizers.QiskitInterface as QI

QI.seed!(seed)

get_eta = QI.powerseries(; eta=a0, power=alpha, offset=A)
get_eps = QI.powerseries(; eta=c0, power=gamma)

spsa = QI.SPSA(length(x0);
    learning_rate = get_eta,
    perturbation = get_eps,
    kwargs...
)

result = QI.minimize(spsa, fn, x0)

```</code></pre><p>Note that <code>QI.SPSA</code> needs a positional argument, not needed in Python. To make up for it, while the <code>result</code> object matches qiskit&#39;s interface exactly,     the <code>spsa</code> object contains attributes <code>record</code> and <code>trace</code>,     which, after the call to <code>QI.minimize</code>,     have some extra information unavailable to qiskit     (without writing your own callback function).</p><p>To avoid expensive and slightly arbitrary calibration steps,     this module treats <code>learning_rate</code> and <code>perturbation</code> as mandatory. Similarly, when the kwarg <code>blocking</code> is set to true,     the kwarg <code>allowed_increase</code> also becomes mandatory. While the qiskit implementation will perform a calibration     to select problem-informed defaults,     the calibration is not necessarily ... good. So you really should perform that calibration ahead of time     and then manually specify your parameters.</p><p>Interesting note: qiskit&#39;s <code>initial_hessian</code> kwarg seems to be quite useless. That is, it sets the initial hessian,     but the initial hessian is, if I have read the code correctly,     always multiplied by zero before it is ever used. So. Don&#39;t use it. If you really want to, I&#39;ve added an extra kwarg <code>initial_hessian_weight</code>     to the <code>QI.SPSA</code> interface, which can be a non-negative integer. For the record, the <code>SPSAOptimizers</code> package does permit an initial hessian,     but it would requires an extra hyperparameter for an &quot;initial weight&quot;,     so let&#39;s just not use it with this <code>QiskitInterface</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/qiskit_interface.jl#L1-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.QiskitInterface.SPSA-Tuple{Int64}" href="#SPSAOptimizers.QiskitInterface.SPSA-Tuple{Int64}"><code>SPSAOptimizers.QiskitInterface.SPSA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SPSA(L; kwargs...)</code></pre><p>Initialize an SPSA optimization. The interface is identical to qiskit&#39;s,     except that there is one required argument <code>L</code> giving the number of parameters,     and the <code>learning_rate</code> and <code>perturbation</code> arguments are mandatory.</p><p>(Unlike in qiskit, the number of parameters has to be fixed ahead of time     to ensure the serializability of the random stream.)</p><p>See here for qiskit&#39;s interface:     https://docs.quantum.ibm.com/api/qiskit/0.28/qiskit.algorithms.optimizers.SPSA</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/qiskit_interface.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPSAOptimizers.QiskitInterface.minimize-Tuple{Any, Any, Any}" href="#SPSAOptimizers.QiskitInterface.minimize-Tuple{Any, Any, Any}"><code>SPSAOptimizers.QiskitInterface.minimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimize(spsa, fn, x0)</code></pre><p>Run an optimization.</p><p><strong>Parameters</strong></p><ul><li><code>spsa</code> - the result of <code>QiskitInterface.SPSA</code></li><li><code>fn</code> - the function, fn(x) (where x is a vector of parameters)</li><li><code>x0</code> - the initial guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kmsherbertvt/SPSAOptimizers.jl/blob/dc222410274848abf003b220455c61bede3b6d1c/src/qiskit_interface.jl#L251-L261">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 25 July 2024 19:32">Thursday 25 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
